import os
import json
from flask import Flask, render_template, request, redirect, url_for, flash, session, jsonify
from datetime import datetime, timezone
from sqlalchemy import asc, desc
from sqlalchemy.exc import OperationalError, IntegrityError
from sqlalchemy.orm import joinedload
from models import db, EquipmentType, PhysicalActivity, Workout, MetricDescriptor, WorkoutSample, HeartRateSample, WorkoutHRZone, WorkoutSummaryData
import uuid

def format_duration_ms(total_seconds):
	if total_seconds is None or not isinstance(total_seconds, (int, float)) or total_seconds < 0:
		return "00:00.00"
	total_seconds_float = float(total_seconds)
	minutes = int(total_seconds_float // 60)
	remaining_seconds_component = total_seconds_float % 60
	seconds = int(remaining_seconds_component)
	centiseconds = int((remaining_seconds_component - seconds) * 100)
	return f"{minutes:02d}:{seconds:02d}.{centiseconds:02d}"

PER_PAGE = 20

app = Flask(__name__)
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024
app.secret_key = os.environ.get('FLASK_SECRET_KEY', 'your_default_secret_key')

DB_USER = os.environ.get('POSTGRES_USER')
DB_PASSWORD = os.environ.get('POSTGRES_PASSWORD')
DB_NAME = os.environ.get('POSTGRES_DB')
DB_HOST = os.environ.get('POSTGRES_HOST', 'db')

app.config['SQLALCHEMY_DATABASE_URI'] = f'postgresql://{DB_USER}:{DB_PASSWORD}@{DB_HOST}:5432/{DB_NAME}'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

db.init_app(app)

@app.route('/workouts/')
@app.route('/workouts/page/<int:page_num>')
def workouts(page_num=1):
	workouts_pagination = Workout.query.options(
		joinedload(Workout.workout_summary_data)
	).order_by(
		Workout.workout_date.desc(),
		Workout.workout_id.desc()
	).paginate(page=page_num, per_page=PER_PAGE, error_out=False)

	workouts_display_data = []
	for workout in workouts_pagination.items:
		summary_values = {
			'Duration': 'N/A',
			'Distance': 'N/A',
			'Split': 'N/A'
		}
		for summary_item in workout.workout_summary_data:
			if summary_item.property_key == 'Duration':
				summary_values['Duration'] = summary_item.value_text
			elif summary_item.property_key == 'derivedTotalDistance':
				summary_values['Distance'] = summary_item.value_text
			elif summary_item.property_key == 'derivedSplit500m':
				summary_values['Split'] = summary_item.value_text
		
		workouts_display_data.append({
			'workout_obj': workout,
			'summary': summary_values
		})

	if not workouts_pagination.items and page_num > 1 and workouts_pagination.pages > 0 :
		return redirect(url_for('workouts', page_num=workouts_pagination.pages))
	elif not workouts_pagination.items and page_num > 1 and workouts_pagination.pages == 0:
		return redirect(url_for('workouts', page_num=1))

	return render_template(
		'workouts.html',
		workouts_pagination=workouts_pagination,
		workouts_display_data=workouts_display_data
	)

@app.route('/', methods=['GET'])
def homepage():
	return render_template('index.html')

@app.route('/submit_json_workout', methods=['POST'])
def submit_json_workout():
	raw_json_data = request.form.get('jsonData')
	if not raw_json_data:
		flash('No JSON data provided.', 'danger')
		return redirect(url_for('homepage'))

	try:
		json_data = json.loads(raw_json_data)
	except json.JSONDecodeError:
		flash('Invalid JSON format.', 'danger')
		return redirect(url_for('homepage'))

	try:
		workout_main_container = json_data.get('data', {})
		if not workout_main_container:
			flash('Main "data" object is missing or empty in the submitted JSON.', 'danger')
			return redirect(url_for('homepage'))

		equipment_name = workout_main_container.get('equipmentType')
		equipment_type = None
		if equipment_name:
			equipment_type = EquipmentType.query.filter_by(name=equipment_name).first()
			if not equipment_type:
				equipment_type = EquipmentType(name=equipment_name)
				db.session.add(equipment_type)
				db.session.flush()

		pa_guid_str = workout_main_container.get('physicalActivityId')
		pa_name = workout_main_container.get('physicalActivityName')
		physical_activity = None
		if pa_guid_str and pa_name:
			try:
				pa_guid = uuid.UUID(pa_guid_str)
				physical_activity = PhysicalActivity.query.get(pa_guid)
				if not physical_activity:
					physical_activity = PhysicalActivity(physical_activity_guid=pa_guid, name=pa_name)
					db.session.add(physical_activity)
					db.session.flush()
			except ValueError:
				flash(f"Invalid Physical Activity GUID: {pa_guid_str}", "danger")

		cardio_log_id = workout_main_container.get('cardioLogId')
		if not cardio_log_id:
			flash('Cardio Log ID is missing within the main "data" object of the JSON.', 'danger')
			return redirect(url_for('homepage'))

		existing_workout = Workout.query.filter_by(cardio_log_id=cardio_log_id).first()
		if existing_workout:
			flash(f'Workout with Cardio Log ID {cardio_log_id} already exists.', 'warning')
			return redirect(url_for('view_workout', workout_id=existing_workout.workout_id))

		workout_date_str = workout_main_container.get('date')
		try:
			workout_date_obj = datetime.strptime(workout_date_str, '%d/%m/%Y').date()
		except (ValueError, TypeError):
			flash(f'Invalid date format: {workout_date_str}. Expected DD/MM/YYYY.', 'danger')
			return redirect(url_for('homepage'))

		new_workout = Workout(
			cardio_log_id=cardio_log_id,
			equipment_type_id=equipment_type.equipment_type_id if equipment_type else None,
			workout_name=workout_main_container.get('name'),
			workout_date=workout_date_obj,
			target_description=workout_main_container.get('target'),
			is_favorite=bool(workout_main_container.get('favorite', 0)),
			physical_activity_guid=physical_activity.physical_activity_guid if physical_activity else None,
			n_eser=workout_main_container.get('nEser'),
			n_attr=workout_main_container.get('nAttr'),
			imported_at=datetime.now(timezone.utc)
		)
		db.session.add(new_workout)
		db.session.flush()

		descriptors_json = workout_main_container.get('analitics', {}).get('descriptor', [])
		metric_descriptor_map = {}
		for desc_json in descriptors_json:
			metric_desc = MetricDescriptor(
				workout_id=new_workout.workout_id,
				json_index=desc_json.get('i'),
				metric_name=desc_json.get('pr', {}).get('name'),
				unit_of_measure=desc_json.get('pr', {}).get('um')
			)
			db.session.add(metric_desc)
			db.session.flush()
			metric_descriptor_map[metric_desc.json_index] = metric_desc

		samples_json = workout_main_container.get('analitics', {}).get('samples', [])
		for sample_json in samples_json:
			time_offset = sample_json.get('t')
			values = sample_json.get('vs', [])
			for i, value in enumerate(values):
				descriptor = metric_descriptor_map.get(i)
				if descriptor:
					workout_sample = WorkoutSample(
						workout_id=new_workout.workout_id,
						metric_descriptor_id=descriptor.metric_descriptor_id,
						time_offset_seconds=time_offset,
						value=value
					)
					db.session.add(workout_sample)

		hr_samples_json = json_data.get('hr')
		location_found = "top level"
		if not hr_samples_json:
			hr_samples_json = workout_main_container.get('hr')
			location_found = "main 'data' object"
			if not hr_samples_json:
				analitics_data = workout_main_container.get('analitics', {})
				hr_samples_json = analitics_data.get('hr', [])
				location_found = "analitics object"
				if not hr_samples_json:
					location_found = "not found"
		
		if hr_samples_json:
			for hr_sample_json_item in hr_samples_json:
				hr_val = hr_sample_json_item.get('hr')
				time_val = hr_sample_json_item.get('t')
				if hr_val is not None:
					hr_sample = HeartRateSample(
						workout_id=new_workout.workout_id,
						time_offset_seconds=time_val,
						heart_rate_bpm=hr_val
					)
					db.session.add(hr_sample)
		elif location_found != "not found":
			pass

		hr_zones_json = json_data.get('hrZones')
		location_found_zones = "top level"
		if not hr_zones_json:
			hr_zones_json = workout_main_container.get('hrZones')
			location_found_zones = "main 'data' object"
			if not hr_zones_json:
				analitics_data = workout_main_container.get('analitics', {})
				hr_zones_json = analitics_data.get('hrZones', [])
				location_found_zones = "analitics object"
				if not hr_zones_json:
					location_found_zones = "not found"
		
		if hr_zones_json:
			for zone_json_item in hr_zones_json:
				hr_zone = WorkoutHRZone(
					workout_id=new_workout.workout_id,
					zone_name=zone_json_item.get('name'),
					color_hex=zone_json_item.get('color'),
					lower_bound_bpm=zone_json_item.get('lowerBound'),
					upper_bound_bpm=zone_json_item.get('upperBound'),
					seconds_in_zone=zone_json_item.get('secondsInZone')
				)
				db.session.add(hr_zone)
		elif location_found_zones != "not found":
			pass

		summary_entries_json = workout_main_container.get('data', [])
		original_summary_data_objects = []
		for entry_json in summary_entries_json:
			summary_data = WorkoutSummaryData(
				workout_id=new_workout.workout_id,
				property_key=entry_json.get('property'),
				display_name=entry_json.get('name'),
				value_text=entry_json.get('value'),
				unit_of_measure=entry_json.get('uM'),
				raw_value=entry_json.get('rawValue')
			)
			db.session.add(summary_data)
			original_summary_data_objects.append(summary_data)

		db.session.flush()

		total_distance_meters = None
		total_duration_seconds_for_split = None

		distance_descriptor = None
		current_workout_descriptors = MetricDescriptor.query.filter_by(workout_id=new_workout.workout_id).all()
		for desc in current_workout_descriptors:
			if desc.metric_name and "distance" in desc.metric_name.lower():
				distance_descriptor = desc
				break
		
		if distance_descriptor:
			last_distance_sample = WorkoutSample.query.filter_by(
				workout_id=new_workout.workout_id,
				metric_descriptor_id=distance_descriptor.metric_descriptor_id
			).order_by(WorkoutSample.time_offset_seconds.desc()).first()

			if last_distance_sample and last_distance_sample.value is not None:
				total_distance_meters = float(last_distance_sample.value)
				if not WorkoutSummaryData.query.filter_by(workout_id=new_workout.workout_id, property_key='derivedTotalDistance').first():
					dist_summary = WorkoutSummaryData(
						workout_id=new_workout.workout_id,
						property_key='derivedTotalDistance',
						display_name='Total Distance (Derived)',
						value_text=f"{total_distance_meters:.0f} m",
						unit_of_measure='m',
						raw_value=total_distance_meters
					)
					db.session.add(dist_summary)
			else:
				pass
		else:
			pass

		duration_keys_for_split = ["duration", "totaltime", "elapsedtime", "workoutduration", "totalduration"]
		
		for item in original_summary_data_objects:
			if item.property_key and item.property_key.lower() in duration_keys_for_split:
				try:
					raw_duration_value = float(item.raw_value)
					unit_of_measure = item.unit_of_measure.lower() if item.unit_of_measure else ""

					if unit_of_measure == "min" or unit_of_measure == "minute" or unit_of_measure == "minutes":
						total_duration_seconds_for_split = raw_duration_value * 60
					elif unit_of_measure == "s" or unit_of_measure == "sec" or unit_of_measure == "second" or unit_of_measure == "seconds" or not unit_of_measure:
						total_duration_seconds_for_split = raw_duration_value
					else:
						continue

					if total_duration_seconds_for_split is not None:
						break
				except (ValueError, TypeError) as e:
					pass
		
		if total_duration_seconds_for_split is None:
			 pass

		if total_duration_seconds_for_split is not None and total_distance_meters is not None and total_distance_meters > 0:
			split_seconds_per_500m = (total_duration_seconds_for_split / total_distance_meters) * 500
			formatted_split = format_duration_ms(split_seconds_per_500m)
			if not WorkoutSummaryData.query.filter_by(workout_id=new_workout.workout_id, property_key='derivedSplit500m').first():
				split_summary = WorkoutSummaryData(
					workout_id=new_workout.workout_id,
					property_key='derivedSplit500m',
					display_name='Avg Split /500m (Derived)',
					value_text=formatted_split,
					unit_of_measure='/500m',
					raw_value=split_seconds_per_500m
				)
				db.session.add(split_summary)
		else:
			if not WorkoutSummaryData.query.filter_by(workout_id=new_workout.workout_id, property_key='derivedSplit500m').first():
				split_summary_na = WorkoutSummaryData(
					workout_id=new_workout.workout_id,
					property_key='derivedSplit500m',
					display_name='Avg Split /500m (Derived)',
					value_text='N/A',
					unit_of_measure='/500m',
					raw_value=None
				)
				db.session.add(split_summary_na)

		db.session.commit()
		flash('Workout data submitted successfully!', 'success')
		return redirect(url_for('view_workout', workout_id=new_workout.workout_id))

	except IntegrityError as e:
		db.session.rollback()
		flash(f'Database integrity error: {str(e.orig)}. Perhaps this workout already exists?', 'danger')
	except Exception as e:
		db.session.rollback()
		flash(f'Error submitting workout: {str(e)}', 'danger')
	
	return redirect(url_for('homepage'))

@app.route('/details/<int:workout_id>')
def view_workout(workout_id):
	workout = Workout.query.options(
		joinedload(Workout.equipment_type_ref),
		joinedload(Workout.physical_activity_ref),
		joinedload(Workout.metric_descriptors).raiseload('*'),
		joinedload(Workout.workout_hr_zones),
		joinedload(Workout.workout_summary_data)
	).get_or_404(workout_id)

	all_workout_samples_query = WorkoutSample.query.options(
		joinedload(WorkoutSample.metric_descriptor_ref)
	).filter_by(workout_id=workout_id).order_by(WorkoutSample.time_offset_seconds.asc())

	total_workout_samples = all_workout_samples_query.count()
	
	first_10_workout_samples = all_workout_samples_query.limit(10).all()
	last_10_workout_samples = []
	workout_samples_ellipsis_needed = False

	if total_workout_samples > 10:
		if total_workout_samples <= 20:
			last_10_workout_samples = all_workout_samples_query.offset(10).limit(10).all()
		else:
			workout_samples_ellipsis_needed = True
			last_10_workout_samples_desc = WorkoutSample.query.options(
				joinedload(WorkoutSample.metric_descriptor_ref)
			).filter_by(workout_id=workout_id).order_by(WorkoutSample.time_offset_seconds.desc()).limit(10).all()
			last_10_workout_samples = list(reversed(last_10_workout_samples_desc))

	all_hr_samples_query = HeartRateSample.query.filter_by(workout_id=workout_id).order_by(HeartRateSample.time_offset_seconds.asc())
	
	total_hr_samples = all_hr_samples_query.count()

	first_10_hr_samples = all_hr_samples_query.limit(10).all()
	last_10_hr_samples = []
	hr_samples_ellipsis_needed = False

	if total_hr_samples > 10:
		if total_hr_samples <= 20:
			last_10_hr_samples = all_hr_samples_query.offset(10).limit(10).all()
		else:
			hr_samples_ellipsis_needed = True
			last_10_hr_samples_desc = HeartRateSample.query.filter_by(workout_id=workout_id).order_by(HeartRateSample.time_offset_seconds.desc()).limit(10).all()
			last_10_hr_samples = list(reversed(last_10_hr_samples_desc))
			
	return render_template(
		'details.html',
		workout=workout,
		first_10_workout_samples=first_10_workout_samples,
		last_10_workout_samples=last_10_workout_samples,
		total_workout_samples=total_workout_samples,
		workout_samples_ellipsis_needed=workout_samples_ellipsis_needed,
		first_10_hr_samples=first_10_hr_samples,
		last_10_hr_samples=last_10_hr_samples,
		total_hr_samples=total_hr_samples,
		hr_samples_ellipsis_needed=hr_samples_ellipsis_needed
	)

@app.route('/first_run')
def first_run():
	try:
		with app.app_context():
			db.create_all()
		flash("Database tables created (or ensured to exist) successfully!", "success")
		return redirect(url_for('homepage'))
	except Exception as e:
		flash(f"Error creating tables: {str(e)}", "danger")
		return redirect(url_for('homepage'))

if __name__ == '__main__':
	with app.app_context():
		db.create_all()
	app.run(host='0.0.0.0', port=5000, debug=True)